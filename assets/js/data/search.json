[ { "title": "Python 패키지 관리의 진화: Poetry 도입 배경과 사용법", "url": "/posts/python-poetry-introduction/", "categories": "python", "tags": "poetry, python, dependency-management, 패키지관리", "date": "2025-05-10 02:00:00 +0900", "snippet": "Python 생태계에서 패키지 설정 관리란, 프로젝트의 의존성과 배포 관련 정보를 정의하고 유지하는 일련의 작업을 의미합니다. 여기에는 외부 패키지 버전 지정, 가상 환경 관리, 빌드와 배포 설정, 메타데이터 작성 등이 포함됩니다.Poetry가 등장하기 이전에는 pip, virtualenv, requirements.txt, setup.py 등을 함께 ...", "content": "Python 생태계에서 패키지 설정 관리란, 프로젝트의 의존성과 배포 관련 정보를 정의하고 유지하는 일련의 작업을 의미합니다. 여기에는 외부 패키지 버전 지정, 가상 환경 관리, 빌드와 배포 설정, 메타데이터 작성 등이 포함됩니다.Poetry가 등장하기 이전에는 pip, virtualenv, requirements.txt, setup.py 등을 함께 사용했습니다. 각각의 도구는 용도가 달라, 패키지 설치, 가상 환경 관리, 의존성 고정, 배포 설정 등 여러 작업을 따로 처리해야 했습니다. 설정 파일은 분산되고, 도구마다 방식이 달라 혼란이 많았습니다. 표준이 없다 보니 각 프로젝트마다 방식이 달랐고, 이를 해결하려는 다양한 서드파티 도구들이 오히려 생태계를 더 복잡하게 만들기도 했습니다.이러한 문제를 해결하고자 등장한 도구가 Poetry입니다. 이 글에서는 기존 방식의 한계와 Poetry가 이를 어떻게 극복하는지, 다른 유사 도구들과의 비교, 그리고 Poetry의 실사용 방법까지 순서대로 정리합니다.기존 Python 패키지 관리 방식의 한계Python에서 패키지를 관리할 때 전통적으로 사용되던 방식은 다음과 같습니다: 의존성 관리: pip, requirements.txt 가상 환경: virtualenv, venv 패키지 배포 설정: setup.py, setup.cfg이러한 조합을 사용하는 과정에서 다음과 같은 불편함이 자주 발생합니다: 의존성 불일치 및 충돌requirements.txt에 명시된 패키지 버전은 하위 의존성까지 통제하지 않으며, 프로젝트 간 환경을 일관되게 유지하기 어렵습니다. 가상 환경 관리의 번거로움venv는 별도 디렉토리에서 생성되며, 수동으로 활성화하거나 .gitignore를 따로 구성해야 합니다. 중복된 설정 파일 관리setup.py, requirements.txt, MANIFEST.in 등 설정 정보가 여러 파일에 흩어져 있어 유지 보수가 어렵습니다. 배포 프로세스의 복잡성실제 PyPI에 패키지를 올리려면, 빌드 도구 설정, twine을 통한 업로드 등을 별도로 처리해야 합니다. Poetry 소개 단일 구성 파일: pyproject.toml의존성, 패키징, 메타데이터 모두를 한 파일에 통합하여 관리합니다. 또한, pyproject.toml은 PEP 518에서 정의된 Python 표준 빌드 시스템 설정 파일로, Poetry는 이를 기반으로 빌드 시스템과 의존성 관리를 통합합니다. 가상 환경 자동 생성 및 관리프로젝트 루트 기준으로 독립적인 가상 환경을 생성하고, 내부적으로 venv를 이용하되 CLI에서 자동으로 관리합니다. 정확한 의존성 잠금: poetry.lockpoetry.lock 파일은 실제 머신에 설치되는 패키지 버전을 고정합니다. 이를 통해 팀원의 로컬 개발 환경과 실제 운영 환경에서 발생할 수 있는 패키지 버전 차이로 인한 오류나 버그를 예방할 수 있습니다. 이 파일은 poetry add, poetry update 등의 명령을 실행할 때 자동으로 생성되거나 갱신됩니다. 사용자가 수동으로 작성할 필요가 없으며, pyproject.toml을 기반으로 전체 의존성 트리를 해석한 결과가 이 파일에 저장됩니다. 빌드 및 배포까지 포괄하는 CLIPoetry는 build, publish, version 명령을 통해 패키지의 배포 과정을 자동화합니다. build: 프로젝트를 PyPI 업로드에 적합한 .tar.gz, .whl 형식의 아카이브로 빌드합니다. publish: 빌드된 패키지를 Python 패키지 저장소(Python Package Index, PyPI)나 기타 지정한 저장소에 업로드합니다. version: pyproject.toml의 버전 번호를 자동으로 증가시키며, 버전 관리 전략(예: 패치, 마이너, 메이저)에 따라 조절할 수 있습니다. 간결하고 직관적인 CLIpoetry add, poetry install, poetry update 등의 명령으로 대부분의 작업을 수행할 수 있습니다.Poetry 설치 방법다음 명령어 중 하나를 사용하여 Poetry를 설치할 수 있습니다.# pipx를 사용하여 설치 (권장)pipx install poetry# curl을 사용하여 설치 (Linux/macOS)curl -sSL https://install.python-poetry.org | python3 -# PowerShell을 사용하여 설치 (Windows)(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py -설치 후, poetry --version 명령어로 정상적으로 설치되었는지 확인할 수 있습니다.Poetry 사용 방법프로젝트 생성Poetry는 기존 프로젝트에 적용하거나 새로운 프로젝트의 골격을 생성할 수 있는 명령어를 제공합니다. 다음은 자주 사용하는 옵션입니다: --name: 프로젝트 이름을 지정합니다. (예: poetry new --name example_project) --src: src/ 디렉토리 기반 프로젝트로 생성합니다. (예: poetry new --src my_project)# 기존 프로젝트에 Poetry를 초기화합니다.poetry init# 새 프로젝트를 생성합니다.poetry new my_project의존성 관리Poetry는 의존성 관리를 자동화하며, 개발용과 배포용 의존성을 명확히 구분해 추가할 수 있도록 합니다. 아래 옵션들은 모두 poetry add 명령어에서 사용되는 대표적인 옵션들입니다: --dev: 개발 의존성으로 추가합니다. (예: poetry add --dev pytest)테스트, 코드 정적 분석, 포매터 등 런타임에 사용되지 않는 도구를 분리해 관리할 수 있습니다. --optional: 선택적(optional) 의존성으로 추가합니다. (예: poetry add some-package --optional)꼭 필요한 것은 아니지만, 일부 환경에서만 필요한 패키지를 명시할 때 사용합니다.사용자는 extras 옵션을 통해 선택적으로 설치할 수 있습니다. --group: 특정 의존성 그룹에 추가합니다. (예: poetry add some-lib --group test)개발, 테스트, 문서화 등 목적별로 의존성을 논리적으로 구분해 관리할 수 있으며, poetry install --with test 와 같이 필요한 그룹만 선택해 설치할 수 있습니다. # 의존성 추가# poetry add 명령어는 외부 패키지를 프로젝트에 추가하는 데 사용됩니다.# 기본적으로 [tool.poetry.dependencies]에 기록되며,# --dev 옵션을 사용하면 [tool.poetry.dev-dependencies]에 기록됩니다.poetry add requestspoetry add --dev black# 의존성 설치# poetry.lock 파일에 명시된 의존성 버전을 기준으로 실제 패키지를 설치합니다.# --no-root: 현재 프로젝트를 설치하지 않고 의존성만 설치합니다.# --only &lt;group&gt;: 특정 그룹 의존성만 설치합니다. (예: --only dev)# --with &lt;group&gt;: 기본 그룹 외에 추가 그룹까지 함께 설치합니다. (예: --with test)poetry install# 잠금 파일 갱신# poetry.lock 파일을 최신 버전으로 갱신하고 다시 잠급니다.# --dry-run: 실제 변경 없이 어떤 패키지가 변경될지를 시뮬레이션합니다.# --lock: 실제 패키지를 설치하지 않고 poetry.lock 파일만 갱신합니다.poetry update가상 환경Poetry는 프로젝트별로 자동으로 가상 환경을 생성하고 이를 CLI 명령어로 쉽게 확인하거나 진입할 수 있도록 지원합니다.# 현재 가상 환경 정보를 확인합니다.poetry env info# 가상 환경에 진입합니다.poetry shell# main.py를 Poetry가 생성한 프로젝트 가상 환경 내에서 실행합니다.poetry run python main.py패키지 빌드 및 배포Poetry는 패키지를 PyPI에 배포할 수 있도록 빌드와 업로드 과정을 모두 CLI로 제공합니다. 주요 옵션은 다음과 같습니다: poetry build -f wheel: .whl 포맷만 빌드합니다. poetry publish --dry-run: 실제 업로드 없이 테스트 실행합니다. poetry publish -r &lt;repository&gt;: 기본이 아닌 다른 저장소로 업로드합니다.Poetry에서는 version 명령어를 통해 pyproject.toml 파일 내의 버전 정보를 쉽게 갱신할 수 있습니다. 이 명령어는 주로 릴리스를 준비할 때 사용되며, 다음과 같이 동작합니다: poetry version patch: 패치 버전(예: 0.1.0 → 0.1.1)을 증가시킵니다. poetry version minor: 마이너 버전(예: 0.1.0 → 0.2.0)을 증가시킵니다. poetry version major: 메이저 버전(예: 0.1.0 → 1.0.0)을 증가시킵니다.버전 변경은 pyproject.toml 파일의 [tool.poetry] 섹션 내 version 필드에 직접 반영됩니다.# 패키지를 빌드합니다.poetry build# PyPI에 업로드합니다.poetry publish --username=__token__ --password=YOUR_TOKENpyproject.toml 구성 예시[tool.poetry]name = \"my_project\"version = \"0.1.0\"description = \"Poetry example project\"authors = [\"Your Name &lt;you@example.com&gt;\"][tool.poetry.dependencies]python = \"^3.10\"requests = \"^2.31.0\"[tool.poetry.dev-dependencies]black = \"^24.3.0\"[build-system]requires = [\"poetry-core\"]build-backend = \"poetry.core.masonry.api\"정리Poetry는 Python의 기존 패키지 관리 생태계가 가진 여러 단점을 효과적으로 개선하는 현대적인 도구입니다. 의존성 관리, 가상 환경, 패키징, 배포를 하나의 워크플로우로 통합하여 생산성을 크게 높여줍니다. 특히 팀 프로젝트나 배포가 필요한 프로젝트에서 그 진가를 발휘합니다. 복잡한 구성을 단순화하고, 유지 보수를 쉽게 하고자 한다면 Poetry는 매우 강력한 선택지입니다.Reference Poetry 공식 문서 PEP 518 – pyproject.toml Comparing Python Packaging Tools" }, { "title": ".NET 컴파일 방식 비교: AOT vs JIT", "url": "/posts/dotnet-jit-vs-aot/", "categories": "dotnet", "tags": "dotnet, jit, aot, compilation", "date": "2025-05-02 18:28:00 +0900", "snippet": ".NET에서는 애플리케이션을 실행 가능한 코드로 변환하는 방식으로 JIT(Just-In-Time)과 AOT(Ahead-Of-Time) 두 가지를 지원합니다. 이 글에서는 두 방식을 비교하고 각각의 특징과 차이점을 정리합니다.주요 내용은 다음과 같습니다. JIT(Just-In-Time) 컴파일 방식 JIT 컴파일러의 종류 AOT(Ahead-Of-T...", "content": ".NET에서는 애플리케이션을 실행 가능한 코드로 변환하는 방식으로 JIT(Just-In-Time)과 AOT(Ahead-Of-Time) 두 가지를 지원합니다. 이 글에서는 두 방식을 비교하고 각각의 특징과 차이점을 정리합니다.주요 내용은 다음과 같습니다. JIT(Just-In-Time) 컴파일 방식 JIT 컴파일러의 종류 AOT(Ahead-Of-Time) 컴파일 방식 AOT와 JIT 비교 Native AOT와 ReadyToRun(R2R) 비교JIT(Just-In-Time) 컴파일 방식JIT 컴파일은 .NET에서 기본적으로 사용하는 컴파일 방식입니다. 일반적으로 .NET 애플리케이션을 빌드하면 IL(Intermediate Language) 코드가 포함된 .dll 또는 .exe 파일이 생성됩니다. 이 파일은 직접 실행되는 것이 아니라, CLR(Common Language Runtime)이라는 실행 환경이 읽어들여 실행합니다.실행 시에는 다음과 같은 흐름을 따릅니다. 프로그램이 실행되면 CLR이 IL 코드를 읽습니다. 메서드가 호출되는 순간, JIT 컴파일러가 해당 메서드를 네이티브 코드(머신 코드)로 변환합니다. 변환된 네이티브 코드는 메모리에 캐시됩니다. 동일한 메서드가 다시 호출될 때는 이미 캐시된 네이티브 코드를 바로 실행합니다.이 때문에 JIT 방식은 첫 호출 시에는 약간의 지연이 발생하지만, 이후 호출에서는 빠른 속도로 실행됩니다. 특징 CLR이 런타임에 필요한 시점에만 메서드를 컴파일합니다. 초기 실행 속도가 느릴 수 있습니다. 실행 중 프로파일링 정보를 활용한 추가 최적화가 가능합니다. 컴파일된 네이티브 코드는 메모리에 캐시되어 재사용됩니다. 장점 다양한 플랫폼(OS, CPU 아키텍처)에서 동일한 IL 바이너리를 재사용할 수 있습니다. 실행 환경에 최적화된 코드를 생성할 수 있습니다. 빌드 속도가 빠릅니다. 단점 메서드 호출 시 초기 컴파일 지연이 발생할 수 있습니다. 런타임 성능이 일관되지 않을 수 있습니다. 메모리 사용량이 증가할 수 있습니다. JIT 컴파일러의 종류JIT 방식은 하나의 컴파일 방식이지만, 이를 실제로 구현한 컴파일러는 플랫폼과 런타임 환경에 따라 다양합니다. 대표적인 JIT 컴파일러는 다음과 같습니다. JIT 컴파일러 설명 RyuJIT .NET Core 및 .NET 5 이상에서 기본으로 사용하는 JIT 컴파일러입니다. x64 및 ARM64 아키텍처를 지원하며, 지속적으로 최적화되고 있습니다. Legacy JIT .NET Framework (특히 32비트 환경)에서 사용되던 이전 세대 JIT 컴파일러입니다. 현재는 유지보수가 중단되었습니다. Mono JIT Xamarin, Unity, 일부 Linux 환경 등 Mono 런타임 기반에서 사용되는 JIT입니다. 플랫폼에 따라 커스터마이징되어 있으며, 다양한 운영체제를 지원합니다. 이러한 JIT 컴파일러는 모두 공통적으로 IL 코드를 실행 시점에 네이티브 코드로 변환하는 방식을 따르지만, 성능, 플랫폼 지원, 내부 최적화 기술 등에서 차이를 가집니다.AOT(Ahead-Of-Time) 컴파일 방식AOT 컴파일은 빌드 타임에 IL 코드를 미리 네이티브 코드로 변환하는 방식입니다. AOT 빌드를 수행하면 생성된 .exe 또는 .dll 파일 안에는 IL이 아니라 완성된 네이티브 코드가 포함됩니다.AOT 실행 흐름은 다음과 같습니다. 빌드 타임에 모든 IL 코드를 네이티브 코드로 변환합니다. 실행 시에는 변환 없이 네이티브 코드를 바로 OS 위에서 실행합니다. CLR을 통한 JIT 컴파일 과정이 필요하지 않습니다. 특징 모든 코드를 사전에 컴파일합니다. 실행 파일 크기가 커질 수 있습니다. 실행 시간이 매우 빠릅니다. 장점 애플리케이션 시작 속도가 빠릅니다. 외부에 CLR을 설치하지 않고 실행할 수 있습니다. 메모리 사용량이 예측 가능합니다. 리버스 엔지니어링이 상대적으로 어렵습니다. 단점 빌드 시간이 길어질 수 있습니다. 리플렉션(reflection)이나 런타임 코드 생성(dynamic code generation)에 제약이 있을 수 있습니다. 빌드 시점에 대부분의 최적화를 완료해야 합니다. AOT vs JIT 비교 항목 JIT AOT 컴파일 시점 런타임 빌드 타임 빌드 산출물 IL 코드(.dll, .exe) 네이티브 코드(.exe, .dll) 실행 속도 초기 느림, 이후 최적화 매우 빠름 빌드 시간 빠름 느림 바이너리 크기 작음 큼 플랫폼 독립성 높음 (IL 공유) 낮음 (플랫폼별 빌드 필요) 런타임 최적화 가능 제한적 Native AOT와 ReadyToRun(R2R) 비교.NET에서는 실행 성능을 개선하기 위한 AOT 컴파일 방식을 여러 형태로 지원합니다. 그 중 대표적인 것이 Native AOT와 ReadyToRun(R2R)입니다. 항목 Native AOT ReadyToRun (R2R) 목적 완전한 네이티브 실행 파일 생성 JIT 부하를 줄여 초기 실행 속도 개선 빌드 결과물 네이티브 코드만 포함 IL + 일부 미리 컴파일된 코드 포함 시스템에 .NET CLR 필요 여부 필요 없음 필요함 파일 크기 상대적으로 작음 상대적으로 큼 런타임 최적화 제한적 일부 가능 리플렉션, 동적 로딩 지원 제한됨 지원 Native AOT 애플리케이션을 완전히 네이티브 바이너리로 컴파일합니다. .NET CLR이 시스템에 없어도 실행할 수 있습니다. 대신, 리플렉션과 런타임 코드 생성 기능에 제약이 있습니다. ReadyToRun (R2R) 주요 코드 경로를 미리 컴파일하여 초기 실행 속도를 개선합니다. 여전히 IL 코드와 함께 빌드되어 .NET CLR이 필요합니다. 런타임 최적화 및 리플렉션 사용이 가능합니다. 정리.NET은 다양한 실행 환경과 성능 요구를 지원하기 위해 JIT과 AOT 두 가지 컴파일 방식을 제공합니다.JIT 방식은 빌드 속도가 빠르고 다양한 플랫폼에 유연하게 대응할 수 있지만, 실행 초기에 지연이 발생할 수 있습니다.반면 AOT 방식은 빌드 시간은 길어지지만, 빠른 시작과 일관된 성능을 제공합니다.애플리케이션의 특성에 따라 다음과 같이 선택할 수 있습니다. 빠른 시작과 배포 파일 일체화를 원할 경우 AOT 방식이 적합합니다. 다양한 플랫폼 호환성과 동적 기능을 중시할 경우 JIT 방식이 유리합니다.또한 AOT 방식 내에서도 Native AOT와 ReadyToRun을 구분하여, CLR 의존성과 배포 방식에 맞게 적절히 선택하는 것이 중요합니다.Reference .NET 공식 문서 - JIT 컴파일러 .NET 공식 문서 - AOT 컴파일러 Microsoft Tech Community - JIT vs AOT" }, { "title": ".NET 플랫폼 정리: 플랫폼, Standard, 구현체, 그리고 변화", "url": "/posts/dotnet-introduction/", "categories": "dotnet", "tags": "dotnet, framework, core, standard", "date": "2025-04-30 03:32:00 +0900", "snippet": ".NET은 Microsoft가 개발한 다양한 유형의 애플리케이션을 위한 개발 플랫폼입니다. 이 글에서는 다음 주제를 다룹니다. .NET 플랫폼이란? .NET의 다양한 구현체들 .NET Standard 사양이란? .NET 5 이전과 이후의 변화.NET 플랫폼이란?.NET은 애플리케이션 개발을 위한 런타임 환경, 언어, 라이브러리를 제공하는 종합적...", "content": ".NET은 Microsoft가 개발한 다양한 유형의 애플리케이션을 위한 개발 플랫폼입니다. 이 글에서는 다음 주제를 다룹니다. .NET 플랫폼이란? .NET의 다양한 구현체들 .NET Standard 사양이란? .NET 5 이전과 이후의 변화.NET 플랫폼이란?.NET은 애플리케이션 개발을 위한 런타임 환경, 언어, 라이브러리를 제공하는 종합적인 개발 플랫폼입니다.이를 통해 Windows, Linux, macOS, iOS, Android 등 다양한 환경에서 동작하는 프로그램을 만들 수 있습니다..NET 플랫폼은 크게 두 가지 주요 구성 요소로 이루어져 있습니다. CLR(Common Language Runtime): 메모리 관리, 스레드 관리, 보안 등 런타임 기능을 제공합니다. BCL(Base Class Library): 파일 입출력, 네트워크, 컬렉션 등 기본 기능을 제공하는 표준 클래스 라이브러리입니다..NET의 다양한 구현체들.NET에는 여러 가지 구현체가 존재합니다. 각 구현체는 다양한 플랫폼을 지원합니다. 구현체 지원 플랫폼 지원 시작일 지원 종료일 .NET Standard 지원 지원 언어 .NET Framework 1.x Windows 2000 이상 2002년 1월 OS 지원 종료 시까지 - C#, VB.NET 등 .NET Framework 4.8.1 Windows 10 이상 2022년 10월 OS 지원 종료 시까지 2.0 C# 7.1 .NET Core 1.0 Windows, Linux, macOS 2016년 6월 2019년 6월 종료 1.6 C#, F# .NET Core 3.1 Windows, Linux, macOS 2019년 11월 2024년 12월까지 장기 지원 2.1 C#, F# Mono Windows, Linux, macOS, iOS, Android 등 2004년 6월 계속 개발 중 일부 C#, F# .NET 5.0 Windows, Linux, macOS, iOS, Android 등 2020년 11월 2022년 5월 종료 - C#, F#, VB.NET .NET Standard 사양이란?.NET Standard는 다양한 .NET 구현체에서 공통적으로 사용할 수 있는 API 규격입니다.이를 통해 하나의 라이브러리로 여러 플랫폼을 지원할 수 있도록 합니다. .NET Framework, .NET Core, Xamarin, Mono 모두가 이 표준을 준수하여 호환성을 유지합니다. .NET Standard를 타겟팅하여 빌드하면, 다양한 플랫폼에서도 별도의 수정 없이 라이브러리를 재사용할 수 있습니다.그러나 .NET 5 출시 이후, 모든 플랫폼을 단일 코드베이스와 런타임(CoreCLR)으로 지원하게 되면서,플랫폼 간 API 차이를 조율할 필요 자체가 줄어들었고,이에 따라 “.NET Standard처럼 사양-구현체를 분리하여 별도 규격을 유지할 필요성”도 사실상 사라지게 되었습니다..NET 5 이전과 이후.NET 5부터는 기존의 .NET Framework, .NET Core, Xamarin, Mono 등 여러 개로 나뉘어 있던 .NET 구현체들을 하나의 통합된 플랫폼으로 재구성하는 전략이 적용되었습니다.이전에는 운영체제나 용도에 따라 별도의 코드베이스와 런타임을 유지해야 했으며, 이는 다음과 같은 문제점을 야기했습니다. 코드 중복: 유사한 기능을 각 구현체마다 별도로 개발하고 유지해야 했습니다. API 버전 관리의 복잡성: 플랫폼마다 API 제공 여부나 동작 방식이 달라, 동일한 기능이라도 플랫폼에 따라 차이가 생겼습니다. 호환성 문제: 개발자가 여러 플랫폼을 동시에 지원하려 할 때, 각 플랫폼에 맞는 별도 버전의 라이브러리나 코드를 작성해야 했습니다. 개발 및 유지보수 비용 증가: 중복 코드와 플랫폼별 이슈로 인해 개발과 테스트, 유지보수에 드는 비용이 크게 증가했습니다.이러한 문제를 완화하기 위해 Microsoft는 .NET Standard를 도입했습니다..NET Standard는 여러 .NET 구현체에서 공통으로 사용할 수 있는 최소 API 집합을 규정하여,라이브러리 개발자가 하나의 API 세트만 지원하면 다양한 플랫폼에서 재사용할 수 있도록 하는 사양(specification) 역할을 했습니다.그러나 .NET 5부터는 모든 플랫폼을 단일 코드베이스와 런타임(CoreCLR)으로 지원하게 되면서,플랫폼 간 API 차이를 조율할 필요 자체가 줄어들었고,이에 따라 “.NET Standard처럼 사양-구현체를 분리하여 별도 규격을 유지할 필요성”도 사실상 사라지게 되었습니다. 특성 .NET Framework 4.x / .NET Core 3.x .NET 5+ (Unified Platform) 코드베이스 플랫폼별 분리 단일 소스 트리 통합 BCL(Base Class Library) 별도 관리 System.* 네임스페이스로 통합 런타임 CLR(Windows), CoreCLR(Linux) 구분 CoreCLR 기반 단일 런타임 컴파일 JIT 중심 기본 JIT, .NET 6+부터 Native AOT 지원 SDK 도구 개별 SDK (netfx, dotnetcore-sdk) 통합 SDK (dotnet) 사용 Reference .NET Standard - Microsoft Learn .NET Framework support policy - Microsoft Learn .NET Architecture Overview - Microsoft Learn Native AOT - Microsoft Learn The future of .NET Standard - .NET Blog .NET 5 Announcement - .NET Blog" }, { "title": "gitignore에서 디렉토리 무시와 파일 무시", "url": "/posts/gitignore_ignore_directory_or_file_diff/", "categories": "git", "tags": "git, gitignore", "date": "2025-04-29 04:40:00 +0900", "snippet": "이 글에서는 gitignore 파일을 사용할 때 디렉토리 무시와 파일 무시의 차이에 대해 설명합니다. 두 방식 모두 불필요한 파일이나 디렉토리가 Git 저장소에 추가되는 것을 방지하기 위해 사용됩니다. 하지만 설정 방법과 동작 방식에는 중요한 차이가 존재합니다.gitignore에서 디렉토리 무시와 파일 무시의 차이디렉토리 무시특정 디렉토리를 무시하려면...", "content": "이 글에서는 gitignore 파일을 사용할 때 디렉토리 무시와 파일 무시의 차이에 대해 설명합니다. 두 방식 모두 불필요한 파일이나 디렉토리가 Git 저장소에 추가되는 것을 방지하기 위해 사용됩니다. 하지만 설정 방법과 동작 방식에는 중요한 차이가 존재합니다.gitignore에서 디렉토리 무시와 파일 무시의 차이디렉토리 무시특정 디렉토리를 무시하려면 디렉토리 이름 뒤에 /를 붙입니다. 디렉토리 전체를 무시하고 싶을 때 사용하는 방식입니다. 작성 방법 예시 logs/temp/ 특징 해당 디렉토리 및 디렉토리 내부의 모든 파일과 하위 디렉토리가 무시됩니다. 디렉토리 이름이 정확히 일치해야 합니다. 주의 사항 디렉토리를 무시하면 해당 디렉토리 자체가 Git의 탐색 대상에서 제외되므로, 하위 파일에 대한 예외 규칙(!)은 적용되지 않습니다. 특정 하위 파일만 추적하려면, 디렉토리 자체를 무시하지 말고 디렉토리 내부 파일 패턴을 세밀하게 지정해야 합니다. 예시 # 잘못된 방식 (하위 파일 예외가 적용되지 않음)logs/!logs/important.log# 올바른 방식 (디렉토리 자체를 무시하지 않고, 하위 파일과 디렉토리를 모두 무시한 뒤 특정 파일만 제외)logs/*!logs/important.log 파일 무시특정 파일을 무시하려면 파일명을 직접 지정하거나 패턴을 사용합니다. 작성 방법 예시 *.log*.tmp.DS_Store 특징 파일명이나 확장자 패턴에 따라 파일만 무시합니다. 디렉토리 구조와 관계없이 지정한 파일만 무시 대상이 됩니다. 주의 사항 이미 Git에 추가된 파일은 .gitignore에 추가하더라도 자동으로 무시되지 않습니다. 추적을 중지하려면 git rm --cached 명령어를 사용해야 합니다. 정리gitignore를 사용할 때는 무시하고자 하는 대상이 디렉토리인지 파일인지 명확히 구분하여 설정해야 합니다. 디렉토리를 무시하면 그 안의 모든 내용이 무시되며, 하위 파일을 선택적으로 추적할 수 없습니다. 파일을 무시할 경우에는 파일 단위로 세밀한 제어가 가능합니다. 이를 이해하고 적절히 설정하면 Git 저장소를 깔끔하게 유지할 수 있습니다. 항목 디렉토리 무시 파일 무시 적용 대상 특정 디렉토리 전체 특정 파일 또는 파일 패턴 작성 방법 디렉토리 이름 뒤에 / 추가 파일 이름 또는 패턴 지정 예시 build/, output/ *.log, error.txt 주요 특징 디렉토리 및 내부 전체 무시 파일만 무시, 디렉토리는 무시하지 않음 주의할 점 하위 파일 예외 적용 불가 이미 커밋된 파일은 별도 삭제 필요 Reference Git 공식 문서 - gitignore 설명 Pro Git Book - Git Basics Ignoring Files" }, { "title": "python package vs module, module import 동작 방식", "url": "/posts/python_package_module_import/", "categories": "python", "tags": "python, import, module, sys.path", "date": "2025-04-28 23:00:00 +0900", "snippet": "본 문서에서는 Python에서 모듈을 import할 때의 동작 방식을 설명합니다. 또한 import 시 경로 문제와 package, module, sub-package, sub-module의 개념 차이도 함께 정리합니다.1. package, module, sub-package, sub-module의 차이 구분 설명 ...", "content": "본 문서에서는 Python에서 모듈을 import할 때의 동작 방식을 설명합니다. 또한 import 시 경로 문제와 package, module, sub-package, sub-module의 개념 차이도 함께 정리합니다.1. package, module, sub-package, sub-module의 차이 구분 설명 예시 Package module들의 집합으로, 폴더 단위로 관리되며 일반적으로 __init__.py 파일을 가짐 utils/ 폴더 Module 하나의 Python 파일로 구성된 코드 단위 utils/a.py Sub-package 다른 package 내부에 포함된 하위 package utils/math_utils/ 폴더 Sub-module sub-package 내부에 있는 Python 파일 utils/math_utils/linear.py 추가 설명 Python 3.2까지는 package와 sub-package는 반드시 __init__.py 파일을 가진 디렉토리여야 했습니다. Python 3.3부터는 implicit namespace package가 도입되어, __init__.py 파일이 없어도 디렉토리를 package로 인식할 수 있습니다.2. package 내에 __init__.py가 있을 때와 없을 때의 import 차이 구분 설명 __init__.py 있음 Python이 이 디렉토리를 package로 인식하여 내부 module을 정상적으로 import 가능 __init__.py 없음 Python 3.3 이상에서는 암묵적으로 package로 인식될 수 있으나, 일부 경우 import 오류가 발생할 수 있음 자세한 설명 Python 3.3 이전 버전에서는 __init__.py 파일이 반드시 존재해야만 해당 디렉토리를 package로 인식할 수 있었습니다. Python 3.3 이후부터는 __init__.py가 없어도 디렉토리를 package로 취급할 수 있습니다.3. implicit namespace packagePython 3.3부터는 implicit namespace package 기능이 도입되었습니다. __init__.py 파일이 없는 디렉토리도 package로 인식할 수 있습니다. 이 경우, 해당 디렉토리는 명시적으로 module로 작성된 것이 아니라, 파일 시스템상의 디렉토리 구조만으로 Python이 package로 간주합니다.특징 여러 경로에 분산된 디렉토리들을 하나의 package로 취급할 수 있습니다. import할 때 별도의 초기화 코드가 실행되지 않습니다. (__init__.py가 없기 때문) 일반적인 경우에는 기존의 명시적 package와 똑같이 사용할 수 있습니다.예시/home/user/project/├── animals/│ ├── mammals/│ │ └── dog.py│ └── birds/│ └── eagle.py animals/, mammals/, birds/ 디렉토리에는 __init__.py 파일이 없습니다. 그러나 Python 3.3 이상에서는 다음과 같이 정상적으로 import할 수 있습니다.from animals.mammals import dogfrom animals.birds import eagle주의할 점 implicit namespace package는 초기화 코드를 삽입할 수 없습니다. 패키지별로 초기 설정을 하고 싶다면 여전히 __init__.py 파일을 만들어야 합니다.4. import 문의 동작import 문은 외부 module을 현재 스크립트로 가져오는 역할을 합니다. 동작 순서는 다음과 같습니다. module 이름을 해석합니다. module을 찾기 위해 sys.path 목록을 순서대로 탐색합니다. module 파일을 찾으면 로딩합니다. .py 파일, .pyc 파일, package 디렉토리 등 다양한 형태를 지원합니다. module을 메모리에 로딩한 뒤, sys.modules에 등록합니다. 이미 sys.modules에 있다면 다시 로딩하지 않고 캐시된 객체를 사용합니다. sys.modules 동작 sys.modules는 Python 인터프리터 전체에 대해 하나만 존재하는 전역(global) 딕셔너리입니다. import된 각 module(.py 파일) 이 독립적으로 sys.modules에 등록됩니다. package 단위로 묶어서 관리하지 않고, package도 단순히 하나의 module로서 등록합니다.예시 Key Value (module 객체) package &lt;module 'package' ...&gt; package.module_a &lt;module 'package.module_a' ...&gt; package.module_b &lt;module 'package.module_b' ...&gt; package, package.module_a, package.module_b가 각각 독립적으로 등록됩니다. 동일한 module을 여러 번 import해도 항상 같은 객체(instance)를 사용합니다.import package.module_aimport package.module_aprint(id(package.module_a)) # 항상 같은 id5. from ~ import ~ 문의 동작from 문은 module의 특정 객체를 직접 가져옵니다. 동작 순서는 다음과 같습니다. import 문처럼 module을 찾고 로딩합니다. module이 로딩된 후, module 내에서 지정한 이름을 찾아 현재 네임스페이스로 가져옵니다.예시from math import sqrt# 현재 네임스페이스에 'sqrt'가 추가되었는지 확인print('sqrt' in globals()) # Trueprint(globals()['sqrt']) # &lt;built-in function sqrt&gt;# 가져온 sqrt를 실제로 사용print(sqrt(9)) # 3.0 먼저 import math를 수행합니다. 그 후 math module 안에서 sqrt 이름을 찾아 현재 네임스페이스에 등록합니다. 따라서 이후 코드에서는 sqrt(9)처럼 math.sqrt를 다시 명시할 필요 없이 바로 사용할 수 있습니다.6. import할 module의 경로이 문서에서는 다음과 같은 예시 프로젝트 구조를 기준으로 설명합니다./home/user/project/├── main.py├── app.py├── utils/│ ├── __init__.py│ ├── math_utils.py│ └── task_utils.pyPython은 module을 import할 때 sys.path 목록을 순서대로 탐색하여 module을 찾습니다.sys.path 구성 순서: python 명령어로 실행한 진입점 스크립트가 포함된 디렉토리의 절대경로 python main.py로 실행할 때, 진입점 스크립트(main.py)가 포함된 디렉토리의 절대경로를 sys.path[0]에 추가합니다. 예를 들어 현재 작업 디렉토리가 /home/user/project이고, python main.py로 실행하면 sys.path[0]은 /home/user/project가 됩니다. PYTHONPATH 환경 변수에 설정된 디렉토리들 표준 라이브러리 디렉토리 site-packages 디렉토리예시 (sys.path 출력 결과 예시)import sysfor path in sys.path: print(path)출력 예시:/home/user/project/usr/local/lib/python3.11/usr/local/lib/python3.11/site-packagesReference Python 공식 문서 - The import system Python 공식 문서 - sys.path 설명 Python 공식 문서 - PEP 420 (Implicit Namespace Packages) Real Python - Python Modules and Packages – An Introduction" }, { "title": "GetTickCount64 function", "url": "/posts/sysinfoapi.h-GetTickCount64-function/", "categories": "sysinfoapi.h", "tags": "MSDN, Win32, sysinfoapi.h", "date": "2022-03-22 16:56:00 +0900", "snippet": "GetTickCount64 function (sysinfoapi.h) - Win32 apps시스템이 시작된 이후 경과된 시간(밀리초)을 가져옵니다.SyntaxULONGLONG GetTickCount64();Return value밀리초 값입니다.RemarksGetTickCount 함수의 해상도(resolution)는 일반적으로 10 밀리세컨드부터 16 ...", "content": "GetTickCount64 function (sysinfoapi.h) - Win32 apps시스템이 시작된 이후 경과된 시간(밀리초)을 가져옵니다.SyntaxULONGLONG GetTickCount64();Return value밀리초 값입니다.RemarksGetTickCount 함수의 해상도(resolution)는 일반적으로 10 밀리세컨드부터 16 밀리세컨드 범위에 있는 시스템 타이머의 해상도로 한정됩니다. GetTickCount64 함수의 해상도는 GetSystemTimeAdjustment 함수로 조정된 사항에 영향을 받지 않습니다.더 높은 해상도의 타이머를 만드려면, multimedia timer 또는 high-resolution timer을 사용하세요.시스템이 시작된 이후 working state에서 보낸 시간을 얻으려면, QueryUnbiasedInterruptTime 함수를 사용하세요. note:QueryUnbiasedInterruptTime 함수는 Windows의 디버그(’선택’) 빌드에서 다른 결과를 낳습니다. 인터럽트 타임 카운트와 틱 카운트가 약 49일 앞당기기 때문입니다. 이는 시스템이 오랫동안 실행될 때까지 발생하지 않을 수 있는 버그를 식별하는 데 도움이 됩니다.이 함수를 사용하는 애플리케이션을 컴파일하려면, _WIN32_WINNT를 0x0600 이상으로 정의하세요. 더 많은 정보를 보려면, Using the Windows Headers 문서를 보세요." }, { "title": "GetThreadTimes function", "url": "/posts/processthreadsapi.h-GetThreadTimes-function/", "categories": "processthreadsapi.h", "tags": "MSDN, Win32, processthreadsapi.h", "date": "2022-03-22 15:45:00 +0900", "snippet": "GetThreadTimes function (processthreadsapi.h) - Win32 apps지정된 스레드의 시간 정보를 가져옵니다.SyntaxBOOL GetThreadTimes( [in] HANDLE hThread, [out] LPFILETIME lpCreationTime, [out] LPFILETIME lpExitTime,...", "content": "GetThreadTimes function (processthreadsapi.h) - Win32 apps지정된 스레드의 시간 정보를 가져옵니다.SyntaxBOOL GetThreadTimes( [in] HANDLE hThread, [out] LPFILETIME lpCreationTime, [out] LPFILETIME lpExitTime, [out] LPFILETIME lpKernelTime, [out] LPFILETIME lpUserTime);Parameters[in] hThread타이밍 정보를 찾는 스레드에 대한 핸들입니다. 이 핸들은 반드시 THREAD_QUERY_INFORMATION 또는 THREAD_QUERY_LIMITED_INFORMATION 접근 권한을 가져야 합니다. 더 많은 정보를 보려면, Thread Security and Access Rights 문서를 보세요.Windows Server 2003 and Windows XP: 이 핸들은 반드시 THREAD_QUERY_INFORMATION 접근 권한을 가져야 합니다.[out] lpCreationTime스레드의 생성 시간(creation time)을 수신하는 FILETIME 구조체에 대한 포인터입니다.[out] lpExitTime스레드의 종료 시간(exit time)을 수신하는 FILETIME 구조체에 대한 포인터입니다. 스레드가 종료되지 않았다면, 이 구조체에 쓰여질 값은 미정의입니다.[out] lpKernelTime스레드가 커널 모드에서 실행된 시간을 수신하는 FILETIME 구조체에 대한 포인터입니다.[out] lpUserTime스레드가 유저 모드에서 실행된 시간을 수신하는 FILETIME 구조체에 대한 포인터입니다.Return value함수가 성공하면, 반환 값은 0이 아닙니다.함수가 실패하면, 반환 값은 0입니다. 더 많은 에러 정보를 가져오려면, GetLastError를 호출하세요.Remarks모든 시간 정보는 FILETIME 자료 구조체를 사용해 표현됩니다. 이러한 구조체는 100나노초 시간 단위의 64비트 카운트를 형성하기 위해 결합되는 2개의 32비트 값이 포함됩니다.스레드 생성 시간과 종료 시간은 1601년 1월 1일 영국 그리니치에서 자정 이후 경과된 시간 time point로 표현됩니다. 애플리케이션이 이런 값들을 보다 일반적으로 유용한 형태로 변환할 수 있는 몇 개의 함수들이 있습니다. Time Functions 문서를 보세요.스레드 커널 모드 시간과 유저 모드 시간은 시간의 양입니다. 예를 들어, 스레드가 커널 모드에서 1초를 보냈다면, 이 함수는 lpKernelTime으로 지정된 FILETIME 구조체에 천만(10,000,000)의 64비트 값을 채울 것입니다. 그것이 1초에 100나노초 단위의 수입니다. 1 seconds = 1,000 millis = 1,000,000 micros = 1,000,000,000 nanos 1,000,000,000 nanos / 100 nanos = 10,000,000 nanos스레드가 사용한 CPU 클럭 사이클 수를 가져오려면, QueryThreadCycleTime 함수를 사용하세요." }, { "title": "PatBlt function", "url": "/posts/WinGdi.h-PatBlt-function/", "categories": "WinGdi.h", "tags": "MSDN, Win32, WinGdi.h", "date": "2022-03-21 12:50:00 +0900", "snippet": "PatBlt function (wingdi.h) - Win32 appsPatBlt 함수는 지정된 디바이스 컨텍스트에서 현재 선택된 브러시를 사용하여 지정된 사각형을 그립니다. 브러시 색상과 표면 색상(들)은 지정된 래스터 명령을 사용하여 결합됩니다.SyntaxBOOL PatBlt( [in] HDC hdc, [in] int x, [in] i...", "content": "PatBlt function (wingdi.h) - Win32 appsPatBlt 함수는 지정된 디바이스 컨텍스트에서 현재 선택된 브러시를 사용하여 지정된 사각형을 그립니다. 브러시 색상과 표면 색상(들)은 지정된 래스터 명령을 사용하여 결합됩니다.SyntaxBOOL PatBlt( [in] HDC hdc, [in] int x, [in] int y, [in] int w, [in] int h, [in] DWORD rop);Parameters[in] hdc디바이스 컨텍스트에 대한 핸들입니다.[in] x채워질 rectangle의 좌상단 모서리의 x 좌표입니다 (논리적 단위).[in] y채워질 rectangle의 좌상단 모서리의 y 좌표입니다 (논리적 단위).[in] w사각형의 너비입니다 (논리적 단위).[in] h사각형의 높이입니다 (논리적 단위).[in] rop래스터 명령 코드입니다. 이 코드는 다음 값 중 하나가 될 수 있습니다. 값 의미 PATCOPY 목적지 비트맵에 지정된 패턴을 복사합니다. PATINVERT 불린 XOR 연산을 사용하여 지정된 패턴의 색상을 목적지 rectangle의 색상과 결합합니다. DSTINVERT 목적지 rectangle을 반전합니다. BLACKNESS 목적지 rectangle을 물리적 팔레트 내 인덱스 0과 연결된 색상을 사용하여 채웁니다 (이 색상은 기본 물리적 팔레트의 경우 검정색입니다). WHITENESS 목적지 rectangle을 물리적 팔레트 내 인덱스 1과 연결된 색상을 사용하여 채웁니다 (이 색상은 기본 물리적 팔레트의 경우 흰색입니다). Return value함수가 성공하면, 리턴 값은 0이 아닙니다.함수가 실패하면, 리턴 값은 0입니다.Remarks이 함수의 dwRop 파라미터의 값은 전체 256개의 삼항 래스터 명령 코드들의 제한된 하위 집합입니다. 특히, source rectangle을 참조하는 명령 코드는 사용할 수 없습니다.모든 디바이스들이 PatBlt 함수를 지원하지는 않습니다. 더 많은 정보를 보려면, GetDeviceCaps 함수 문서의 RC_BITBLT capability의 설명을 보세요.Examples예제 코드를 보려면, Using Menus 문서의 “Example of Menu-Item Bitmaps” 항목을 보세요." }, { "title": "ID3D11Device::CreateBuffer method", "url": "/posts/Direct3D-ID3D11DeviceCreateBuffer-method/", "categories": "Direct3D", "tags": "MSDN, DirectX, Direct3D", "date": "2022-03-20 23:07:00 +0900", "snippet": "ID3D11Device::CreateBuffer (d3d11.h) - Win32 apps버퍼를 생성합니다 (vertex buffer, index buffer, 또는 shader-constant buffer).SyntaxHRESULT CreateBuffer( [in] const D3D11_BUFFER_DESC *pDesc,...", "content": "ID3D11Device::CreateBuffer (d3d11.h) - Win32 apps버퍼를 생성합니다 (vertex buffer, index buffer, 또는 shader-constant buffer).SyntaxHRESULT CreateBuffer( [in] const D3D11_BUFFER_DESC *pDesc, [in, optional] const D3D11_SUBRESOURCE_DATA *pInitialData, [out, optional] ID3D11Buffer **ppBuffer);Parameters[in] pDescType: const D3D11_BUFFER_DESC*버퍼를 기술한 D3D11_BUFFER_DESC 구조체에 대한 포인터입니다.[in, optional] pInitialDataType: const D3D11_SUBRESOURCE_DATA*초기화 데이터를 기술한 D3D11_SUBRESOURCE_DATA 구조체에 대한 포인터입니다. 공간만 할당하려면 nullptr를 사용하세요 (예외적으로 usage flag가 D3D11_USAGE_IMMUTABLE인 경우 nullptr로 설정할 수 없습니다).pInitialData에 어떠한 것도 전달하지 않는다면, 버퍼에 대한 메모리의 초기 내용은 정의되지 않습니다. 이 경우, 리소스를 읽기 전에 다른 방법으로 버퍼의 내용을 채워넣어야 합니다.[out, optional] ppBufferType: ID3D11Buffer**생성된 버퍼 객체에 대한 ID3D11Buffer 인터페이스에 대한 포인터입니다. 다른 입력 매개변수가 유효한지 검사하려면 이 매개변수를 nullptr로 설정하세요 (S_FALSE는 통과를 나타냅니다).Return valueType: HRESULT이 메소드는 버퍼를 만들기 위해 필요한 메모리가 부족한 경우, E_OUTOFMEMORY를 반환합니다. 다른 가능한 반환값을 보려면, Direct3D 11 Return Codes 문서를 보세요.Remarks예제 코드를 보려면, How to: Create a Vertex Buffer, How to: Create an Index Buffer 또는 How to: Create a Constant Buffer 문서를 보세요.constant buffer에 대해서는, D3D11_BUFFER_DESC의 ByteWidth를 반드시 16의 배수로 설정해야 하며, D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT 보다 작거나 같게 설정해야 합니다.Windows 8과 이후 버전에서 사용 가능한 Direct3D 11.1 런타임은 CreateBuffer에 대해 다음과 같은 새로운 기능을 제공합니다.셰이더가 접근 가능한 최대 constant buffer 크기보다 더 큰 constant buffer를 생성할 수 있습니다 (4096 32-bit * 4 component constants - 64KB). 파이프라인에 constant buffer를 바인드할 때, 4096 상수 제한 내에 맞는, 셰이더가 접근 가능한 버퍼의 범위를 정의할 수 있습니다.Windows 8과 이후 버전에서 사용 가능한 Direct3D 11.1 런타임은 feature level 9.1, 9.2, 그리고 9.3에 대해 이 기능을 에뮬레이트합니다. 그러므로, 이 기능은 feature level 9.1, 9.2, 그리고 9.3에서 지원됩니다.이 기능은 feature level 10 이상의 새 드라이버에서 항상 사용할 수 있습니다.Direct3D 11.1보다 예전 버전의 런타임에서는, CreateBuffer를 호출해 4096보다 큰 constant buffer 생성을 요청하는 것은 실패합니다." }, { "title": "D3D11_BUFFER_DESC structure", "url": "/posts/Direct3D-D3D11_BUFFER_DESC/", "categories": "Direct3D", "tags": "MSDN, DirectX, Direct3D", "date": "2022-03-20 21:54:00 +0900", "snippet": "D3D11_BUFFER_DESC (d3d11.h) - Win32 apps버퍼 리소스를 기술합니다.Syntaxtypedef struct D3D11_BUFFER_DESC { UINT ByteWidth; D3D11_USAGE Usage; UINT BindFlags; UINT CPUAccessFlags; UINT...", "content": "D3D11_BUFFER_DESC (d3d11.h) - Win32 apps버퍼 리소스를 기술합니다.Syntaxtypedef struct D3D11_BUFFER_DESC { UINT ByteWidth; D3D11_USAGE Usage; UINT BindFlags; UINT CPUAccessFlags; UINT MiscFlags; UINT StructureByteStride;} D3D11_BUFFER_DESC;MembersByteWidthType: UINT버퍼의 크기(바이트)입니다.UsageType: D3D11_USAGE버퍼에서 어떻게 읽고 쓸 것으로 기대되는지에 대해 식별합니다. 업데이트 빈도는 핵심 요소입니다. 가장 일반적인 값은 D3D11_USAGE_DEFAULT 입니다. D3D11_USAGE 문서를 읽어 가능한 모든 값들을 보세요.BindFlagsType: UINT버퍼가 어떻게 파이프라인에 바인드되었는지에 대해 식별합니다. 플래그는 비트 단위 OR로 결합될 수 있습니다. (D3D11_BIND_FLAG)CPUAccessFlagsType: UINTCPU 액세스 플래그 (D3D11_CPU_ACCESS_FLAG)이거나, 또는 CPU 액세스가 필요하지 않은 경우 0입니다. 플래그는 비트 단위 OR로 결합될 수 있습니다.MiscFlagsType: UINT여러 가지 잡다한 플래그이거나, 또는 사용되지 않는 경우 0입니다. 플래그는 비트 단위 OR로 결합될 수 있습니다.StructureByteStrideType: UINT버퍼가 구조화된 버퍼를 나타낼 때 버퍼 구조 내에 있는 각 요소들의 크기(바이트)입니다. 구조화된 버퍼에 대한 더 많은 정보를 보려면, Structured Buffer 문서를 보세요.StructureByteStride의 크기 값은 사용하는 버퍼의 뷰에 사용하는 형식의 크기와 일치해야 합니다. 예를 들어, pixel shader에서 버퍼를 읽기 위해 shader resource view (SRV)를 사용한다면, SRV format 크기는 반드시 StructureByteStride 내의 크기 값과 일치해야 합니다.Remarks이 구조체는 ID3D11Device::CreateBuffer에서 버퍼 리소스를 만들 때 사용합니다.이 구조체 외에, D3D11.h에 정의되어 있으며 상속된 클래스처럼 동작하는 CD3D11_BUFFER_DESC의 하위 타입을 사용하여 buffer description을 생성할 수 있습니다.bind flag가 D3D11_BIND_CONSTANT_BUFFER일 때, 반드시 ByteWidth를 16의 배수로 설정해야 하며, D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT 보다 작거나 같아야 합니다." }, { "title": "ID3D11RenderTargetView interface", "url": "/posts/Direct3D-ID3D11RenderTargetView-interface/", "categories": "Direct3D", "tags": "MSDN, DirectX, Direct3D", "date": "2022-03-19 23:57:00 +0900", "snippet": "ID3D11RenderTargetView (d3d11.h) - Win32 apps렌더 타겟 뷰 인터페이스는 렌더링 중 액세스 가능한 subresources의 렌더 타겟입니다.InheritanceID3d11RenderTargetView 인터페이스는 ID3D11View를 상속합니다.ID3d11RenderTargetView는 또한 다음 유형의 멤버들도 있습...", "content": "ID3D11RenderTargetView (d3d11.h) - Win32 apps렌더 타겟 뷰 인터페이스는 렌더링 중 액세스 가능한 subresources의 렌더 타겟입니다.InheritanceID3d11RenderTargetView 인터페이스는 ID3D11View를 상속합니다.ID3d11RenderTargetView는 또한 다음 유형의 멤버들도 있습니다.Methods| ID3D11RenderTargetView::GetDesc | 렌더 타겟 뷰의 속성들을 가져옵니다. || — | — |Remarks렌더 타겟 뷰를 생성하려면, ID3D11Device::CreateRenderTargetView을 호출하세요. 파이프라인에 렌더 타겟 뷰를 바인드하려면, ID3D11DeviceContext::OMSetRenderTargets을 호출하세요.렌더 타겟은 render pass가 끝날 때 output-merger 단계에서 쓰여질 수 있는(can be written) 리소스입니다. 각 렌더 타겟은 대응되는 depth-stencil 뷰를 가지고 있어야 합니다." }, { "title": "Using SSE/SSE2 for optimization", "url": "/posts/cpp-Using-SSE-or-SSE2-for-optimization/", "categories": "cpp", "tags": "CodeProject, cpp", "date": "2022-03-19 23:19:00 +0900", "snippet": "Using SSE/SSE2 for optimization최적화 방법 중 하나에 대한 초보자용 소개입니다.fast_data_transfer_demo.zipObjective본 게시물의 목적은 간단한 최적화 방법을 소개하는 것입니다. 나중에 더 많은 글을 투고할 계획입니다.Introduction본 게시물은 Intel의 SIMD (Single Instruct...", "content": "Using SSE/SSE2 for optimization최적화 방법 중 하나에 대한 초보자용 소개입니다.fast_data_transfer_demo.zipObjective본 게시물의 목적은 간단한 최적화 방법을 소개하는 것입니다. 나중에 더 많은 글을 투고할 계획입니다.Introduction본 게시물은 Intel의 SIMD (Single Instruction Multiple Data) extension 기술에 대해 설명합니다. movdqa같이 기존의 방식보다 더 빠르게 데이터를 전송할 수 있는, Intel의 새로운 instruction을 사용하여 최적화합니다.Recall시작하기 전에, 우리가 이미 알고 있는 지식들을 상기해봅시다. 요즘, 또는 일반적으로, 우리는 집에서, 또한 산업에서 32비트 프로세서를 사용하고 있습니다. eax, ebx, .. 와 같은 범용 목적의 레지스터들은 32비트입니다. 그리고 sizeof(int) = 4 (bytes) 입니다. 그러나 모든 레지스터들이 32비트인 것은 아니며, 더 많은 비트 길이를 가지는 레지스터들이 있습니다. 10년 전부터, Intel은 64비트를 가지는 8개의 레지스터 mm0, mm1 .. mm7이 있는 MMX extension을 도입했습니다. 그 이후, Intel은 128비트를 가지는 다른 새로운 레지스터 xmm0, xmm1 .. xmm7이 있는 SSE extension을 도입했습니다.Requirement먼저 자신이 어떤 기기를 사용하고 있는지 알아보세요. Intel P3 이상이어야 합니다. 이 최적화 방법은 기기에 의존적이라는 것을 명심해야 합니다. 이는 자신의 하드웨어가 지원하지 않는다면, 차이를 볼 수 없다는 것을 의미합니다.Code제가 만든 샘플입니다. 콘솔 모드에서 실행될 수 있도록 일부러 간단하게 만들었습니다. 복사 붙여넣기 하지 않고, 독자가 이해하며 스스로 시도해보는 것을 권장합니다.데모 코드는 같은 목적으로 제공되는 두 함수의 차이점을 확인시켜 줄 것입니다. 여기서부터 더 많은 설명을 하지 않을 것입니다. 스스로 코드를 보며 코드 내의 주석을 읽어주세요. 이해할 수 있을 것이라 확신합니다. =)잠깐! 먼저 브레이크 포인트를 준비하고 인내심을 가지고 기다리세요. 디버깅을 할 때, 다음 두 함수를 모두 step해보면 차이점을 알 수 있을 것입니다. DataTransferTypical은 한 루프에 하나의 int를 복사할 것이고 (sizeof(int) = 4 bytes), 반면 DataTransferOptimised는 한 루프에 한 루프에 4개의 int를 복사할 것입니다 (4 * sizeof(int) = 16 bytes).Watch 창을 준비하세요. Watch창에서 piDst, 101을 watch하세요. 그 뒤 어떻게 변하는지 확인하세요. P.S: 이 코드를 MSVC++로 컴파일하기 위해 processor pack을 설치해야 합니다.int DataTransferTypical(int* piDst, int* piSrc, unsigned long SizeInBytes);int DataTransferOptimised(int* piDst, int* piSrc, unsigned long SizeInBytes);// stdafx.h : include file for standard system include files,// or project specific include files that are used frequently, but// are changed infrequently//#if !defined(AFX_STDAFX_H__CCA0779D_0F4D_4A56_A148_738F06155CA8__INCLUDED_)#define AFX_STDAFX_H__CCA0779D_0F4D_4A56_A148_738F06155CA8__INCLUDED_#if _MSC_VER &gt; 1000#pragma once#endif // _MSC_VER &gt; 1000#define WIN32_LEAN_AND_MEAN\t\t// Exclude rarely-used stuff from Windows headers#include &lt;stdio.h&gt;// TODO: reference additional headers your program requires here//// Microsoft Visual C++ will insert additional declarations immediately before the previous line.#endif // !defined(AFX_STDAFX_H__CCA0779D_0F4D_4A56_A148_738F06155CA8__INCLUDED_)#include \"stdafx.h\"#include &lt;conio.h&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include \"malloc.h\"#define ITERATION 10#define DATA_SIZE 0x00100000int DataTransferTypical(int* piDst, int* piSrc, unsigned long SizeInBytes);int DataTransferOptimised(int* piDst, int* piSrc, unsigned long SizeInBytes);int main(int argc, char* argv[]){\t// 시작 시간과 종료 시간을 기억합니다.\t// 만약 더 정확한 것을 원한다면, 다른 게시물을 찾아보세요.\tunsigned long dwTimeStart = 0;\tunsigned long dwTimeEnd = 0;\t// 임시 변수입니다.\tint* piSrc = nullptr;\tint* piDst = nullptr;\tint i = 0;\tchar cKey = 0;\tunsigned long dwDataSizeInBytes = sizeof(int) * DATA_SIZE;\t// 이 코드를 msvc++으로 컴파일하기 위해 processor pack을 설치해야 합니다.\tpiSrc = (int*)_aligned_malloc(dwDataSizeInBytes, dwDataSizeInBytes);\tpiDst = (int*)_aligned_malloc(dwDataSizeInBytes, dwDataSizeInBytes);\tdo\t{\t\t// 초기화 합니다.\t\tmemset(piSrc, 1, dwDataSizeInBytes);\t\tmemset(piDst, 0, dwDataSizeInBytes);\t\tdwTimeStart = clock();\t\tfor (i = 0; i &lt; ITERATION; i++)\t\t\tDataTransferTypical(piDst, piSrc, dwDataSizeInBytes);\t\tdwTimeEnd = clock();\t\tprintf(\"== Typical Transfer of %d * %d times of %d bytes data ==\\\\n Time Elapsed = \"\"% d msec\\\\n\\\\n\",\t\t ITERATION, DATA_SIZE, sizeof(int), dwTimeEnd - dwTimeStart);\t\t// 초기화 합니다.\t\tmemset(piSrc, 1, dwDataSizeInBytes);\t\tmemset(piDst, 0, dwDataSizeInBytes);\t\tdwTimeStart = clock();\t\tfor (i = 0; i &lt; ITERATION; i++)\t\t\tDataTransferOptimised(piDst, piSrc, dwDataSizeInBytes);\t\tdwTimeEnd = clock();\t\tprintf(\"== Optimised Transfer of %d * %d times of %d bytes data ==\\\\n Time Elapsed = % d msec\\\\n\\\\n\",\t\t ITERATION, DATA_SIZE, sizeof(int), dwTimeEnd - dwTimeStart);\t\tprintf(\"Rerun? (y/n) \");\t\tcKey = getche();\t\tprintf(\"\\\\n\\\\n\");\t}\twhile (cKey == 'y');\t_aligned_free(piSrc);\t_aligned_free(piDst);\treturn 0;}#pragma warning(push)#pragma warning(disable:4018 4102)int DataTransferTypical(int* piDst, int* piSrc, unsigned long SizeInBytes){\tunsigned long dwNumElements = SizeInBytes / sizeof(int);\tfor (int i = 0; i &lt; dwNumElements; i++)\t{\t\t// i는 offset입니다.\t\t*(piDst + i) = *(piSrc + i);\t}\treturn 0;}int DataTransferOptimised(int* piDst, int* piSrc, unsigned long SizeInBytes){\tunsigned long dwNumElements = SizeInBytes / sizeof(int);\t// 실제로 사용하지는 않으며 디버깅용 변수입니다.\t// 반복 횟수를 가집니다.\t// 또한 packed 데이터의 개수를 의미하기도 합니다.\tunsigned long dwNumPacks = dwNumElements / (128 / (sizeof(int) * 8));\t_asm\t\t{\t\t// cleanup\t\tpusha;\t\tbegin:\t\t// 카운터를 SizeInBytes으로 초기화합니다.\t\tmov ecx, SizeInBytes;\t\t// destination 포인터를 가져옵니다.\t\tmov edi, piDst;\t\t// source 포인터를 가져옵니다.\t\tmov esi, piSrc;\t\tbegina:\t\t// 카운터가 0이라면, 반복을 종료합니다.\t\tcmp ecx, 0;\t\tjz end;\t\tbody:\t\t// offset을 계산합니다.\t\tmov ebx, SizeInBytes;\t\tsub ebx, ecx;\t\t// source의 내용을 128비트 레지스터에 복사합니다.\t\tmovdqa xmm1, [esi + ebx];\t\t// 128비트 레지스터를 destination에 복사합니다.\t\tmovdqa [edi + ebx], xmm1;\t\tbodya:\t\t// 우리는 이미 1 packed == 4 * sizeof(int)를 수행했습니다.\t\tsub ecx, 16;\t\tjmp begina;\t\tend:\t\t// cleanup\t\tpopa;\t\t}\treturn 0;}#pragma warning(pop)Finally이것은 Code Project에서의 제 첫 게시물입니다. 만약 올바르지 않은 것이 있다면 저에게 알려주세요. 또한, 여기에 올려놓은 데모가 초보자들에게 간단히 도움되었으면 합니다. 배움은 즐겁습니다. 그렇죠? =)" }, { "title": "CheckMultisampleQualityLevels function", "url": "/posts/Direct3D-CheckMultisampleQualityLevels/", "categories": "Direct3D", "tags": "MSDN, DirectX, Direct3D", "date": "2022-03-17 20:20:00 +0900", "snippet": "ID3D11Device::CheckMultisampleQualityLevels (d3d11.h) - Win32 apps다중 샘플링(multisampling) 중 사용 가능한 quality levels의 개수를 반환합니다.SyntaxHRESULT CheckMultisampleQualityLevels( [in] DXGI_FORMAT Format, [...", "content": "ID3D11Device::CheckMultisampleQualityLevels (d3d11.h) - Win32 apps다중 샘플링(multisampling) 중 사용 가능한 quality levels의 개수를 반환합니다.SyntaxHRESULT CheckMultisampleQualityLevels( [in] DXGI_FORMAT Format, [in] UINT SampleCount, [out] UINT *pNumQualityLevels);Parameters[in] FormatType: DXGI_FORMAT텍스처 포맷입니다. DXGI_FORMAT 문서를 보세요.[in] SampleCountType: UINT다중 샘플링 중인 샘플들의 개수입니다.[out] pNumQualityLevelsType: UINT*어댑터가 지원하는 quality levels의 개수입니다. Remarks를 보세요.Return valueType: HRESULT메소드는 Direct3D 11 Return Codes 중 하나를 반환합니다.Remarks텍스처를 다중 샘플링할 때, 어댑터가 사용 가능한 quality levels의 개수는 사용되는 텍스처의 포맷과 요청된 샘플 수에 따라 다릅니다. quality levels의 최대 개수는 D3D11.h 내에 D3D11_MAX_MULTISAMPLE_SAMPLE_COUNT로 정의되어 있습니다.만약 메소드가 S_OK (0)을 반환하며 출력 매개변수인 pNumQualityLevels로 양수를 받았다면, 디바이스는 이 포맷과 샘플 개수 조합을 지원합니다. 만약 사용 불가능한 조합인 경우, 이 메소드는 실패 HRESULT (즉, 음의 정수)를 반환하거나, pNumQualityLevels 출력 매개변수를 0으로 설정하거나, 또는 둘 다 합니다.뿐만 아니라, quality level의 정의는 각 하드웨어 공급업체(vendor)가 정의하도록 남겨둡니다. 그러나 이 정보를 검색하는 데 도움이 되는 기능은 Direct3D에서 제공하지 않습니다.FEATURE_LEVEL_10_1 device들은 R32G32B32A32 및 R32G32B32를 제외한 모든 render target들에 대해 4x MSAA를 지원해야 합니다. FEATURE_LEVEL_11_0 device들은 모든 render target 형식에 대해 4x MSAA를, R32G32B32A32 포맷을 제외한 모든 render target 형식에 8x MSAA를 지원해야 합니다." }, { "title": "D3D11CreateDevice function", "url": "/posts/Direct3D-D3D11CreateDevice-function/", "categories": "Direct3D", "tags": "MSDN, DirectX, Direct3D", "date": "2022-03-17 19:49:00 +0900", "snippet": "D3D11CreateDevice function (d3d11.h) - Win32 apps디스플레이 어댑터를 대표하는 device를 생성합니다.SyntaxHRESULT D3D11CreateDevice( [in, optional] IDXGIAdapter *pAdapter, D3D_DRIVER_TYPE ...", "content": "D3D11CreateDevice function (d3d11.h) - Win32 apps디스플레이 어댑터를 대표하는 device를 생성합니다.SyntaxHRESULT D3D11CreateDevice( [in, optional] IDXGIAdapter *pAdapter, D3D_DRIVER_TYPE DriverType, HMODULE Software, UINT Flags, [in, optional] const D3D_FEATURE_LEVEL *pFeatureLevels, UINT FeatureLevels, UINT SDKVersion, [out, optional] ID3D11Device **ppDevice, [out, optional] D3D_FEATURE_LEVEL *pFeatureLevel, [out, optional] ID3D11DeviceContext **ppImmediateContext);Parameters[in, optional] pAdapterType: IDXGIAdapter*device를 생성할 때 사용하는 비디오 어댑터를 가리키는 포인터입니다. IDXGIFactory1::EnumAdapters에 의해 열거되는 첫 번째 어댑터인 기본 어댑터를 사용하려면 nullptr을 전달하세요. note: 애플리케이션 내에서 DXGI 1.0 (IDXGIFactory)와 DXGI 1.1 (IDXGIFactory1)을 혼용하지 마세요. IDXGIFactory 또는 IDXGIFactory을 사용하되, 둘 다 동시에 사용하지 마세요.DriverTypeType: D3D_DRIVER_TYPE생성할 드라이버의 유형을 표현하는 D3D_DRIVER_TYPE 입니다.SoftwareType: HMODULE소프트웨어 래스터라이저를 구현한 DLL에 대한 핸들입니다. 만약 DriverType이 D3D_DRIVER_TYPE_SOFTWARE라면, Software는 반드시 nullptr이 아니여야 합니다. LoadLibrary, LoadLibraryEx, 또는 GetModuleHandle을 사용해 핸들을 가져옵니다.FlagsType: UINT활성화할 런타임 레이어(runtime layers)들입니다 (D3D11_CREATE_DEVICE_FLAG). 값들은 비트단위로 OR될 수 있습니다.[in, optional] pFeatureLevelsType: const D3D_FEATURE_LEVEL*생성할 때 시도하는 feature levels의 순서를 결정하는 D3D_FEATURE_LEVEL들의 배열을 가리키는 포인터입니다. 만약 pFeatureLevels를 nullptr로 설정한다면, 이 함수는 다음 feature levels의 배열을 사용합니다.{ D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_10_0, D3D_FEATURE_LEVEL_9_3, D3D_FEATURE_LEVEL_9_2, D3D_FEATURE_LEVEL_9_1,}; note: 컴퓨터에 Direct3D 11.1 런타임이 있고 pFeatureLevels를 nullptr로 설정되었을 때, 이 함수는 D3D_FEATURE_LEVEL_11_1 device를 생성하지 않습니다. D3D_FEATURE_LEVEL_11_1 device를 생성하려면, 반드시 D3D_FEATURE_LEVEL_11_1을 포함한 D3D_FEATURE_LEVEL 배열을 명시적으로 제공해야 합니다. 만약 Direct3D 11.1 런타임이 설치되지 않은 컴퓨터에서 D3D_FEATURE_LEVEL_11_1을 포함한 배열을 제공한다면, 이 함수는 E_INVALIDARG를 반환하며 즉시 실패합니다.FeatureLevelsType: UINTpFeatureLevels 내 요소의 개수입니다.SDKVersionType: UINTSDK의 버전입니다. D3D11_SDK_VERSION을 사용하세요.[out, optional] ppDeviceType: D3D_FEATURE_LEVEL*성공했을 때, pFeatureLevels 배열에서 성공한 첫 번째 D3D_FEATURE_LEVEL을 반환합니다. 지원되는 feature level을 결정할 필요가 없는 경우 nullptr을 입력하세요.[out, optional] ppImmediateContextType: ID3D11DeviceContext**device context를 대표하는 ID3D11DeviceContext 객체를 가리키는 포인터를 반환합니다. 이 매개변수가 nullptr일 때 ID3D11DeviceContext는 반환되지 않습니다.Return valueType: HRESULT메소드는 Direct3D 11 Return Codes 중 하나를 반환할 수 있습니다.만약 pAdapter 매개변수를 nullptr로 설정하지 않았으며 DriverType 매개변수를 D3D_DRIVER_TYPE_HARDWARE 값으로 설정한 경우, 이 함수는 E_INVALIDARG를 반환합니다.만약 Flags로 D3D11_CREATE_DEVICE_DEBUG를 지정했으며 컴퓨터에 잘못된 버전의 debug layer가 설치되어 있는 경우, 이 메소드는 DXGI_ERROR_SDK_COMPONENT_MISSING을 반환합니다.Remarks이 진입점(entry-point)은 Windows 7, Windows Server 2008 R2, 그리고 Windows Vista 업데이트(KB971644)에서 사용할 수 있는 Direct3D 11 런타임에서 지원됩니다.Windows 8, Windows Server 2012, 그리고 Windows 7 과 Platform Update for Windows 7이 설치된 Windows Server 2008 R2에서 사용 가능한 Direct3D 11.1 device를 생성하려면, 먼저 이 함수로 I3D11Device를 생성하고, 그 뒤 ID3D11Device 객체에서 QueryInterface 메소드를 호출하여 ID3D11Device1 인터페이스를 얻으세요.Windows 8.1 그리고 Windows Server 2012 R2에서 사용 가능한 Direct3D 11.2 device를 생성하려면, 먼저 이 함수로 ID3D11Device를 생성하고, 그 뒤 ID3D11Device 객체에서 QueryInterface 메소드를 호출하여 ID3D11Device2 인터페이스를 얻으세요.장치를 생성하지 않고 pFeatureLevel을 보고 지원되는 feature level을 결정하려면, ppDevice와 ppImmediateContext를 nullptr로 설정하세요.예를 들어, device와 스왑 체인을 동시에 생성하려면, D3D11CreateDeviceAndSwapChain을 사용하세요. (How To: Create a Device and Immediate Context)pAdapter 매개변수를 nullptr로 설정하지 않았을 때, 반드시 DriverType 매개변수를 D3D_DRIVER_TYPE_UNKNOWN 값으로 설정해야 합니다. 만약 pAdapter 매개변수가 nullptr이 아니며 DriverType 매개변수를 D3D_DRIVER_TYPE_HARDWARE 값으로 설정한 경우, D3D11CreateDevice는 E_INVALIDARG를 반환합니다." }, { "title": "DXGI_SWAP_CHAIN_DESC structure", "url": "/posts/DXGI-DXGI_SWAP_CHAIN_DESC/", "categories": "DXGI", "tags": "MSDN, DirectX, DXGI", "date": "2022-03-17 18:24:00 +0900", "snippet": "DXGI_SWAP_CHAIN_DESC (dxgi.h) - Win32 appsswap chain을 기술하는 구조체입니다.Syntaxtypedef struct DXGI_SWAP_CHAIN_DESC { DXGI_MODE_DESC BufferDesc; DXGI_SAMPLE_DESC SampleDesc; DXGI_USAGE BufferUsa...", "content": "DXGI_SWAP_CHAIN_DESC (dxgi.h) - Win32 appsswap chain을 기술하는 구조체입니다.Syntaxtypedef struct DXGI_SWAP_CHAIN_DESC { DXGI_MODE_DESC BufferDesc; DXGI_SAMPLE_DESC SampleDesc; DXGI_USAGE BufferUsage; UINT BufferCount; HWND OutputWindow; BOOL Windowed; DXGI_SWAP_EFFECT SwapEffect; UINT Flags;} DXGI_SWAP_CHAIN_DESC;MembersBufferDescType: DXGI_MODE_DESCback buffer 디스플레이 모드를 기술하는 구조체입니다.SampleDescType: DXGI_SAMPLE_DESC멀티샘플링 매개변수들을 기술하는 구조체입니다.BufferUsageType: DXGI_USAGE백 버퍼에 대한 surface 사용량과 CPU 액세스 옵션을 기술한 DXGI_USAGE 열거형 타입의 멤버입니다. 백 버퍼는 셰이더 입력(shader input) 또는 렌더 타겟 출력(render-target output)에 사용될 수 있습니다.BufferCountType: UINT스왑 체인 내의 버퍼 개수를 기술하는 값입니다. IDXGIFactory::CreateSwapChain을 호출하여 풀스크린 스왑 체인을 만들 때, 일반적으로 이 값에 프론트 버퍼를 포함합니다. 스왑 체인 버퍼에 대한 더 많은 정보를 보려면, Remarks를 보세요.OutputWindowType: HWND출력 윈도우에 대한 HWND 핸들입니다. 이 멤버는 반드시 nullptr이 아니여야 합니다.WindowedType: BOOL창 모드로 출력될 것인지를 지정하는 bool 값입니다. TRUE이면 창모드로 출력합니다.창 모드 스왑 체인을 만들고 최종 사용자가 IDXGISwapChain::SetFullscreenState를 통해 스왑 체인을 전체 화면으로 변경할 수 있도록 하는 것을 권장합니다. 즉, 스왑 체인이 강제로 전체 화면이 되도록 이 값을 FALSE로 설정하지 마세요. 스왑 체인을 전체 화면 모드로 생성하는 경우, 지원되지 않는 디스플레이 모드로 스왑 체인을 생성할 때, 디스플레이가 검게 변하고 최종 사용자는 아무 것도 볼 수 없게 됩니다.창 모드를 선택할 것인지 전체 화면 모드를 선택할 것인지에 대한 더 많은 정보를 보려면, IDXGIFactory::CreateSwapChain 문서를 보세요.SwapEffectType: DXGI_SWAP_EFFECTsurface를 표시한 뒤 present buffer의 내용을 처리하기 위한 옵션을 기술하는 DXGI_SWAP_EFFECT 열거형 타입의 멤버입니다.FlagsType: UINT스왑 체인 동작에 대한 옵션을 기술하는 DXGI_SWAP_CHAIN_FLAG 열거형 타입의 멤버입니다.Remarks이 구조체는 GetDesc와 CreateSwapChain 메소드들에 의해 사용됩니다.전체 화면 모드에서는 dedicated front buffer가 있습니다. 창 모드에서 desktop은 frontbuffer입니다.만약 하나의 버퍼만을 가진 스왑 체인을 생성하는 경우, DXGI_SWAP_EFFECT_SEQUENTIAL를 지정해도 단일 버퍼의 내용이 front buffer와 교체되지 않습니다.전체 화면 모드에서 스왑 체인 버퍼를 flip하는 것에 대한 성능 정보를 더 보려면, Full-Screen Application Performance Hints 문서를 보세요." }, { "title": "[WinUser.h] AdjustWindowRect function", "url": "/posts/WinUser.h-AdjustWindowRect/", "categories": "WinUser.h", "tags": "MSDN, Win32, WinUser.h", "date": "2022-03-16 18:11:00 +0900", "snippet": "AdjustWindowRect function (winuser.h) - Win32 apps원하는 클라이언트 rectangle 크기를 기반으로, 윈도우 rectangle의 필요한 크기를 계산합니다. 그런 다음 윈도우 rectangle을 CreateWindow 함수에 전달하여 원하는 크기의 클라이언트 영역을 가진 윈도우를 생성할 수 있습니다.더 많은 윈도...", "content": "AdjustWindowRect function (winuser.h) - Win32 apps원하는 클라이언트 rectangle 크기를 기반으로, 윈도우 rectangle의 필요한 크기를 계산합니다. 그런 다음 윈도우 rectangle을 CreateWindow 함수에 전달하여 원하는 크기의 클라이언트 영역을 가진 윈도우를 생성할 수 있습니다.더 많은 윈도우 스타일을 지정하려면, AdjustWindowRectEx 함수를 사용하세요.SyntaxBOOL AdjustWindowRect( [in, out] LPRECT lpRect, [in] DWORD dwStyle, [in] BOOL bMenu);Parameters[in, out] lpRectType: LPRECT원하는 클라이언트 영역의 왼쪽-상단과 오른쪽-하단 모서리 좌표를 가지고 있는 RECT 구조체를 가리키는 포인터입니다. 함수가 반환되었을 때, 구조체는 원하는 클라이언트 영역을 수용하는 윈도우의 왼쪽 위 모서리와 오른쪽 아래 모서리 좌표를 포함합니다.[in] dwStyleType: DWORD필요한 크기가 계산될 윈도우의 윈도우 스타일입니다. WS_OVERLAPPED 스타일을 지정하지 못한다라는 점에 유의하세요.[in] bMenuType: BOOL윈도우가 메뉴를 가질 것인지 아닌지를 나타냅니다.Return valueType: BOOL함수가 성공하면, 리턴 값은 0이 아닙니다.함수가 실패하면, 리턴 값은 0입니다. 더 많은 오류 정보를 보려면, GetLastError 를 호출하세요.Remarks클라이언트 rectangle은 클라이언트 영역을 완전히 둘러싸는 가장 작은 rectangle입니다. 윈도우 rectangle은 클라이언트 영역과 클라이언트 영역이 아닌 영역을 포함하는, 윈도우를 완전히 둘러싸는 가장 작은 rectangle입니다.AdjustWindowRect 함수는 메뉴 바가 두 개 이상의 행으로 이루어져있을 때 추가 공간을 포함하지 않습니다.AdjustWindowRect 함수는 WS_VSCROLL 또는 WS_HSCROLL 스타일을 고려하지 않습니다. 스크롤 막대를 고려하려면, SM_CXVSCROLL 또는 SM_CYHSCROLL과 함께 GetSystemMetrics 함수를 호출하세요." }, { "title": "[WinUser.h] RegisterClassExW function", "url": "/posts/WinUser.h-RegisterClassExW/", "categories": "WinUser.h", "tags": "MSDN, Win32, WinUser.h", "date": "2022-03-16 12:32:00 +0900", "snippet": "RegisterClassExW function (winuser.h) - Win32 appsCreateWindow 또는 CreateWindowEx 함수를 호출하기 위해 사용할 윈도우 클래스를 등록합니다.SyntaxATOM RegisterClassExA( [in] const WNDCLASSEXA *unnamedParam1);Parameters[in] u...", "content": "RegisterClassExW function (winuser.h) - Win32 appsCreateWindow 또는 CreateWindowEx 함수를 호출하기 위해 사용할 윈도우 클래스를 등록합니다.SyntaxATOM RegisterClassExA( [in] const WNDCLASSEXA *unnamedParam1);Parameters[in] unnamedParam1WNDCLASSEX 구조체에 대한 포인터입니다. 함수에 이것을 전달하기 전에 반드시 구조체에 적절한 클래스 속성들(class attributes)로 채워야 합니다.Return value함수가 성공했다면, 리턴 값은 등록된 클래스를 유일하게 식별하는 class atom입니다. 이 atom은 오로지 CreateWindow, CreateWindowEx, GetClassInfo, GetClassInfoEx, FindWindow, FindWindowEx, 그리고 UnregisterClass 함수와 IActivelMMap::FilterClientWindows 메소드에서만 사용될 수 있습니다.만약 함수가 실패했다면 리턴 값은 0입니다. 더 많은 오류 정보를 보려면, GetLastError 를 호출하세요.Remarks만약 RegisterClassExA를 사용해 윈도우 클래스를 등록한다면, 애플리케이션은 생성된 클래스의 윈도우들이 ANSI 문자열 집합을 사용하기 위해 텍스트 또는 문자 매개변수가 포함된 메세지를 기대한다고 시스템에게 알립니다. 만약 RegisterClassExW를 사용해 등록한다면, 애플리케이션은 시스템이 메세지의 텍스트 매개변수를 유니코드로 전달하도록 요청합니다. IsWindowUnicode 함수를 사용해 각 윈도우의 속성을 쿼리(query)할 수 있습니다. ANSI와 Unicode 함수에 대한 더 많은 정보를 보려면, Conventions for Function Prototypes 문서를 보세요.애플리케이션이 등록한 모든 윈도우 클래스들은 애플리케이션이 종료될 때 모두 등록 해제됩니다.DLL이 언로드될 때 DLL에 의해 등록된 윈도우 클래스들은 등록 해제되지 않습니다. DLL은 언로드될 때 반드시 명시적으로 DLL의 윈도우 클래스들을 등록 해제해야 합니다.Examples예제를 보려면, Using Window Classes 문서를 보세요. Note: winuser.h 헤더는 RegisterClassEx를 UNICODE 전처리기 상수가 정의되어 있는지에 따라 자동으로 이 함수의 ANSI 또는 Unicode 버전을 자동으로 선택하는 별칭(alias)으로 정의합니다." }, { "title": "[MSDN] Creating Threads", "url": "/posts/msdn-creating-threads/", "categories": "Win32", "tags": "MSDN, Win32", "date": "2022-03-15 16:55:00 +0900", "snippet": "Creating Threads - Win32 appsCreateThread 함수는 프로세스에 새로운 스레드를 생성합니다. 생성된 스레드는 반드시 새로운 스레드가 실행할 코드의 시작 주소를 지정해야 합니다. 일반적으로, 시작 주소는 프로그램 코드에 정의된 함수의 이름입니다 (자세한 내용은 ThreadProc 참조). 이 함수는 단일 파라미터를 받으며 D...", "content": "Creating Threads - Win32 appsCreateThread 함수는 프로세스에 새로운 스레드를 생성합니다. 생성된 스레드는 반드시 새로운 스레드가 실행할 코드의 시작 주소를 지정해야 합니다. 일반적으로, 시작 주소는 프로그램 코드에 정의된 함수의 이름입니다 (자세한 내용은 ThreadProc 참조). 이 함수는 단일 파라미터를 받으며 DWORD 값을 반환합니다. 프로세스는 동일한 함수를 실행하는 여러 개의 스레드를 동시에 가질 수 있습니다.아래는 지역적으로 정의된 함수 MyThreadFunction을 실행하는 새로운 스레드를 생성하는 방법에 대한 간단한 예제를 보여줍니다.호출 스레드는 WaitForMultipleObjects 함수를 호출하여 모든 작업자 스레드가 종료될 때까지 지연할 수 있습니다. 대기하는 동안 호출 스레드가 블로킹됩니다. 처리를 계속하려면, 호출 스레드는 WaitForSingleObject를 사용하고 각 작업자 스레드가 wait object에 신호를 보낼 때까지 기다립니다. 종료되기 전에 작업자 스레드에 대한 핸들을 닫으려고 하는 경우, 작업자 스레드를 종료하지 않는다는 것에 유의하세요. 그러나 후속 함수 호출에서는 핸들을 사용할 수 없습니다.#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;strsafe.h&gt;#define MAX_THREADS 3#define BUF_SIZE 255DWORD WINAPI MyThreadFunction( LPVOID lpParam );void ErrorHandler(LPTSTR lpszFunction);// Sample custom data structure for threads to use.// This is passed by void pointer so it can be any data type// that can be passed using a single void pointer (LPVOID).typedef struct MyData { int val1; int val2;} MYDATA, *PMYDATA;int _tmain(){ PMYDATA pDataArray[MAX_THREADS]; DWORD dwThreadIdArray[MAX_THREADS]; HANDLE hThreadArray[MAX_THREADS]; // Create MAX_THREADS worker threads. for( int i=0; i&lt;MAX_THREADS; i++ ) { // Allocate memory for thread data. pDataArray[i] = (PMYDATA) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(MYDATA)); if( pDataArray[i] == NULL ) { // If the array allocation fails, the system is out of memory // so there is no point in trying to print an error message. // Just terminate execution. ExitProcess(2); } // Generate unique data for each thread to work with. pDataArray[i]-&gt;val1 = i; pDataArray[i]-&gt;val2 = i+100; // Create the thread to begin execution on its own. hThreadArray[i] = CreateThread( NULL, // default security attributes 0, // use default stack size MyThreadFunction, // thread function name pDataArray[i], // argument to thread function 0, // use default creation flags &amp;dwThreadIdArray[i]); // returns the thread identifier // Check the return value for success. // If CreateThread fails, terminate execution. // This will automatically clean up threads and memory. if (hThreadArray[i] == NULL) { ErrorHandler(TEXT(\"CreateThread\")); ExitProcess(3); } } // End of main thread creation loop. // Wait until all threads have terminated. WaitForMultipleObjects(MAX_THREADS, hThreadArray, TRUE, INFINITE); // Close all thread handles and free memory allocations. for(int i=0; i&lt;MAX_THREADS; i++) { CloseHandle(hThreadArray[i]); if(pDataArray[i] != NULL) { HeapFree(GetProcessHeap(), 0, pDataArray[i]); pDataArray[i] = NULL; // Ensure address is not reused. } } return 0;}DWORD WINAPI MyThreadFunction( LPVOID lpParam ) { HANDLE hStdout; PMYDATA pDataArray; TCHAR msgBuf[BUF_SIZE]; size_t cchStringSize; DWORD dwChars; // Make sure there is a console to receive output results. hStdout = GetStdHandle(STD_OUTPUT_HANDLE); if( hStdout == INVALID_HANDLE_VALUE ) return 1; // Cast the parameter to the correct data type. // The pointer is known to be valid because // it was checked for NULL before the thread was created. pDataArray = (PMYDATA)lpParam; // Print the parameter values using thread-safe functions. StringCchPrintf(msgBuf, BUF_SIZE, TEXT(\"Parameters = %d, %d\\\\n\"), pDataArray-&gt;val1, pDataArray-&gt;val2); StringCchLength(msgBuf, BUF_SIZE, &amp;cchStringSize); WriteConsole(hStdout, msgBuf, (DWORD)cchStringSize, &amp;dwChars, NULL); return 0; } void ErrorHandler(LPTSTR lpszFunction) { // Retrieve the system error message for the last-error code. LPVOID lpMsgBuf; LPVOID lpDisplayBuf; DWORD dw = GetLastError(); FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, dw, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) &amp;lpMsgBuf, 0, NULL ); // Display the error message. lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT, (lstrlen((LPCTSTR) lpMsgBuf) + lstrlen((LPCTSTR) lpszFunction) + 40) * sizeof(TCHAR)); StringCchPrintf((LPTSTR)lpDisplayBuf, LocalSize(lpDisplayBuf) / sizeof(TCHAR), TEXT(\"%s failed with error %d: %s\"), lpszFunction, dw, lpMsgBuf); MessageBox(NULL, (LPCTSTR) lpDisplayBuf, TEXT(\"Error\"), MB_OK); // Free error-handling buffer allocations. LocalFree(lpMsgBuf); LocalFree(lpDisplayBuf);}MyThreadFunction 함수는 특히 multithreaded CRT를 사용하지 않는 경우, 많은 함수가 not thread-safe하기 때문에 C 런타임 라이브러리 (CRT, C run-time library)의 사용을 피합니다. 만약 ThreadProc함수 내에서 CRT를 사용하고 싶다면, _beginthreadex 함수를 대신 사용하세요.포인터가 유효하지 않게 되어버리기 때문에, 생성 스레드(새로운 스레드를 생성한 부모 스레드)가 새로운 스레드보다 먼저 종료된다면 지역 변수의 주소를 전달하는 것은 위험합니다. 대신, 동적으로 할당된 메모리에 대한 포인터를 전달하거나 새로운 스레드가 종료될 때까지 생성 스레드를 기다리게 하세요. 데이터는 또한 전역 변수로도 전달될 수도 있습니다. 전역 변수를 사용하면, 일반적으로 여러 스레드의 액세스를 동기화해야 합니다. 더 많은 정보를 보려면 Synchronizing Execution of Multiple Threads 문서를 보세요.생성 스레드는 인수로 다음 항목들을 지정할 수 있습니다. 새로운 스레드에 대한 핸들의 보안 속성들(security attributes)입니다. 이러한 보안 속성에는 핸들이 자식 프로세스에 의해 상속될 수 있는지 아닌지에 대한 여부를 결정하는 inheritance flag를 포함됩니다. 또한 액세스가 허용되기 전에 시스템이 스레드 핸들의 모든 후속 사용에 대한 액세스 검사를 수행하는 데 사용하는 보안 설명자(security descriptor)가 포함됩니다. 새로운 스레드의 초기 스택 크기입니다. 스레드의 스택은 프로세스의 메모리 영역에 자동으로 할당됩니다. 시스템은 필요할 때마다 스택의 크기를 늘리며 스레드가 종료될 때 이를 해제합니다. 더 많은 정보를 보려면 Thread Stack Size 문서를 보세요. 일시 중단(suspended) 상태로 스레드를 생성할 수 있도록 해주는 생성 플래그(creation flag)입니다. 일시 중단되었을 때 스레드는 ResumeThread 함수가 호출되기 전까지 실행되지 않습니다.또한 CreateRemoteThread 함수를 사용하여 스레드를 생성할 수도 있습니다. 이 함수는 디버그 중인 프로세스의 주소 공간 영역에서 실행되는 스레드를 생성하기 위해서 디버거에 의해 사용됩니다." }, { "title": "[MSDN] Creating Processes", "url": "/posts/msdn-creating-processes/", "categories": "Win32", "tags": "MSDN, Win32", "date": "2022-03-15 01:19:00 +0900", "snippet": "Creating Processes - Win32 appsCreateProcess 함수는 생성 프로세스(=CreateProcess를 호출한 프로세스)와 독립적으로 실행되는 새로운 프로세스를 생성합니다. 그러나 편의상, 이 관계를 부모-자식 관계라고 합니다.아래 코드는 어떻게 프로세스를 만드는지 보여줍니다.#include &lt;windows.h&gt;#...", "content": "Creating Processes - Win32 appsCreateProcess 함수는 생성 프로세스(=CreateProcess를 호출한 프로세스)와 독립적으로 실행되는 새로운 프로세스를 생성합니다. 그러나 편의상, 이 관계를 부모-자식 관계라고 합니다.아래 코드는 어떻게 프로세스를 만드는지 보여줍니다.#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;void _tmain( int argc, TCHAR *argv[] ){ STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory( &amp;si, sizeof(si) ); si.cb = sizeof(si); ZeroMemory( &amp;pi, sizeof(pi) ); if( argc != 2 ) { printf(\"Usage: %s [cmdline]\\\\n\", argv[0]); return; } // Start the child process. if( !CreateProcess( NULL, // No module name (use command line) argv[1], // Command line NULL, // Process handle not inheritable NULL, // Thread handle not inheritable FALSE, // Set handle inheritance to FALSE 0, // No creation flags NULL, // Use parent's environment block NULL, // Use parent's starting directory &amp;si, // Pointer to STARTUPINFO structure &amp;pi ) // Pointer to PROCESS_INFORMATION structure ) { printf( \"CreateProcess failed (%d).\\\\n\", GetLastError() ); return; } // Wait until child process exits. WaitForSingleObject( pi.hProcess, INFINITE ); // Close process and thread handles. CloseHandle( pi.hProcess ); CloseHandle( pi.hThread );}만약 CreateProcess가 성공한다면, 새로운 프로세스와 이것의 기본 스레드의 핸들들과 식별자들이 담긴 PROCESS_INFORMATION 구조체를 반환합니다. 스레드와 프로세스 핸들들은 전체 액세스 권한으로 생성되지만, 보안 설명자를 지정하면 액세스가 제한될 수 있습니다. 이 핸들들이 더 이상 필요하지 않게 된다면, CloseHandle 함수를 사용해 이들을 닫아줄 수 있습니다.또한 CreateProcessAsUser 또는 CreateProcessWithLogon 함수를 사용하여 프로세스를 생성할 수 있습니다. 이를 통해 프로세스가 실행될 사용자 계정의 보안 컨텍스트를 지정할 수 있습니다." }, { "title": "[MSDN] Changing Environment Variables", "url": "/posts/msdn-changing-environment-variables/", "categories": "Win32", "tags": "MSDN, Win32", "date": "2022-03-14 23:28:00 +0900", "snippet": "Changing Environment Variables - Win32 apps각 프로세스는 그것과 연관된 환경 블럭을 가지고 있습니다. 환경 블럭은 블럭 끝에 두 개의 null 바이트를 가지는 블럭으로 구성되며, 여기에서 각 문자열은 다음 형식으로 되어 있습니다.name=value환경 블럭 내의 모든 문자열들은 반드시 이름을 기준으로 알파벳 순으로 정...", "content": "Changing Environment Variables - Win32 apps각 프로세스는 그것과 연관된 환경 블럭을 가지고 있습니다. 환경 블럭은 블럭 끝에 두 개의 null 바이트를 가지는 블럭으로 구성되며, 여기에서 각 문자열은 다음 형식으로 되어 있습니다.name=value환경 블럭 내의 모든 문자열들은 반드시 이름을 기준으로 알파벳 순으로 정렬되어야 합니다. 정렬은 대소문자를 구분하지 않고, 유니코드 순서이며, 로케일에 관계 없습니다. 등호 기호(equal sign)이 구분자(separator)이기 때문에, 이것(=등호)을 환경 변수의 이름으로 사용하면 안 됩니다.Example 1기본적으로, 자식 프로세스는 부모 프로세스의 환경 블럭의 복사본을 상속받습니다. 아래 예제는 CreateProcess를 사용하여 자식 프로세스에 전달할 새로운 환경 블럭을 만드는 방법을 보여줍니다.이 예제에서는 예제 3의 코드를 자식 프로세스인 ex3.exe로 사용합니다.#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;stdio.h&gt;#include &lt;strsafe.h&gt;#define BUFSIZE 4096int _tmain(){ TCHAR chNewEnv[BUFSIZE]; LPTSTR lpszCurrentVariable; DWORD dwFlags=0; TCHAR szAppName[]=TEXT(\"ex3.exe\"); STARTUPINFO si; PROCESS_INFORMATION pi; BOOL fSuccess; // Copy environment strings into an environment block. lpszCurrentVariable = (LPTSTR) chNewEnv; if (FAILED(StringCchCopy(lpszCurrentVariable, BUFSIZE, TEXT(\"MySetting=A\")))) { printf(\"String copy failed\\\\n\"); return FALSE; } lpszCurrentVariable += lstrlen(lpszCurrentVariable) + 1; if (FAILED(StringCchCopy(lpszCurrentVariable, BUFSIZE, TEXT(\"MyVersion=2\")))) { printf(\"String copy failed\\\\n\"); return FALSE; } // Terminate the block with a NULL byte. lpszCurrentVariable += lstrlen(lpszCurrentVariable) + 1; *lpszCurrentVariable = (TCHAR)0; // Create the child process, specifying a new environment block. SecureZeroMemory(&amp;si, sizeof(STARTUPINFO)); si.cb = sizeof(STARTUPINFO);#ifdef UNICODE dwFlags = CREATE_UNICODE_ENVIRONMENT;#endif fSuccess = CreateProcess(szAppName, NULL, NULL, NULL, TRUE, dwFlags, (LPVOID) chNewEnv, // new environment block NULL, &amp;si, &amp;pi); if (! fSuccess) { printf(\"CreateProcess failed (%d)\\\\n\", GetLastError()); return FALSE; } WaitForSingleObject(pi.hProcess, INFINITE); return TRUE;}Example 2프로세스 생성 중 자식 프로세스의 환경 변수를 바꾸는 것은 한 프로세스가 다른 프로세스의 환경 변수를 직접적으로 변경할 수 있는 유일한 방법입니다. 프로세스는 그의 자식 프로세스가 아닌 다른 프로세스의 환경 변수를 절대로 직접 변경할 수 없습니다.만약 자식 프로세스가 약간의 변경점 외 대부분의 환경을 상속받도록 하려면, 다음 예제와 같이 GetEnvironmentVariable을 사용해 현재 값들을 가져오고, 이 값들을 저장하고, 자식 프로세스가 상속할 업데이트된 블럭을 블럭을 생성하고, 자식 프로세스를 프로세스를 만든 뒤, SetEnvironmentVariable을 사용해 저장했던 변수들을 복원합니다.이 예제에서는 예제 3의 코드를 자식 프로세스인 ex3.exe로 사용합니다.#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;stdio.h&gt;#define BUFSIZE 4096#define VARNAME TEXT(\"MyVariable\")int _tmain(){ DWORD dwRet, dwErr; LPTSTR pszOldVal; TCHAR szAppName[]=TEXT(\"ex3.exe\"); DWORD dwFlags=0; STARTUPINFO si; PROCESS_INFORMATION pi; BOOL fExist, fSuccess; // Retrieves the current value of the variable if it exists. // Sets the variable to a new value, creates a child process, // then uses SetEnvironmentVariable to restore the original // value or delete it if it did not exist previously. pszOldVal = (LPTSTR) malloc(BUFSIZE*sizeof(TCHAR)); if(NULL == pszOldVal) { printf(\"Out of memory\\\\n\"); return FALSE; } dwRet = GetEnvironmentVariable(VARNAME, pszOldVal, BUFSIZE); if(0 == dwRet) { dwErr = GetLastError(); if( ERROR_ENVVAR_NOT_FOUND == dwErr ) { printf(\"Environment variable does not exist.\\\\n\"); fExist=FALSE; } } else if(BUFSIZE &lt; dwRet) { pszOldVal = (LPTSTR) realloc(pszOldVal, dwRet*sizeof(TCHAR)); if(NULL == pszOldVal) { printf(\"Out of memory\\\\n\"); return FALSE; } dwRet = GetEnvironmentVariable(VARNAME, pszOldVal, dwRet); if(!dwRet) { printf(\"GetEnvironmentVariable failed (%d)\\\\n\", GetLastError()); return FALSE; } else fExist=TRUE; } else fExist=TRUE; // Set a value for the child process to inherit. if (! SetEnvironmentVariable(VARNAME, TEXT(\"Test\"))) { printf(\"SetEnvironmentVariable failed (%d)\\\\n\", GetLastError()); return FALSE; } // Create a child process. SecureZeroMemory(&amp;si, sizeof(STARTUPINFO)); si.cb = sizeof(STARTUPINFO); #ifdef UNICODE dwFlags = CREATE_UNICODE_ENVIRONMENT;#endif fSuccess = CreateProcess(szAppName, NULL, NULL, NULL, TRUE, dwFlags, NULL, // inherit parent's environment NULL, &amp;si, &amp;pi); if (! fSuccess) { printf(\"CreateProcess failed (%d)\\\\n\", GetLastError()); } WaitForSingleObject(pi.hProcess, INFINITE); // Restore the original environment variable. if(fExist) { if (! SetEnvironmentVariable(VARNAME, pszOldVal)) { printf(\"SetEnvironmentVariable failed (%d)\\\\n\", GetLastError()); return FALSE; } } else SetEnvironmentVariable(VARNAME, NULL); free(pszOldVal); return fSuccess;}Example 3아래 예제에서는 GetEnvironmentStrings을 사용하여 프로세스의 환경 블럭을 가져오고 콘솔에 내용을 출력합니다.#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;stdio.h&gt;int _tmain(){ LPTSTR lpszVariable; LPTCH lpvEnv; // Get a pointer to the environment block. lpvEnv = GetEnvironmentStrings(); // If the returned pointer is NULL, exit. if (lpvEnv == NULL) { printf(\"GetEnvironmentStrings failed (%d)\\\\n\", GetLastError()); return 0; } // Variable strings are separated by NULL byte, and the block is // terminated by a NULL byte. lpszVariable = (LPTSTR) lpvEnv; while (*lpszVariable) { _tprintf(TEXT(\"%s\\\\n\"), lpszVariable); lpszVariable += lstrlen(lpszVariable) + 1; } FreeEnvironmentStrings(lpvEnv); return 1;}" } ]
